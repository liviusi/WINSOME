\documentclass[11pt, italian, openany]{book}
% Set page margins
\usepackage[margin=2cm]{geometry}

\usepackage[]{graphicx}
\usepackage{setspace}
\usepackage{fontspec}
\usepackage{amsmath}
\usepackage{amssymb}
\setmainfont{TeX Gyre Termes}
\singlespace % interlinea singola

\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,
	urlcolor=blue,
}
 
% All page numbers positioned at the bottom of the page
\usepackage{fancyhdr}
\fancyhf{} % clear all header and footers
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\pagestyle{fancy}

% Changes the style of chapter headings
\usepackage{titlesec}

\titleformat{\chapter}
   {\normalfont\LARGE\bfseries}{\thechapter.}{1em}{}

% Change distance between chapter header and text
\titlespacing{\chapter}{0pt}{35pt}{\baselineskip}
\usepackage{titlesec}
\titleformat{\section}
  [hang] % <shape>
  {\normalfont\bfseries\Large} % <format>
  {} % <label>
  {0pt} % <sep>
  {} % <before code>
\renewcommand{\thesection}{} % Remove section references...
\renewcommand{\thesubsection}{\arabic{subsection}} %... from subsections

% Numbered subsections
\setcounter{secnumdepth}{3}

% Prevents LaTeX from filling out a page to the bottom
\raggedbottom

\usepackage{color}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{minted}
\definecolor{bg}{rgb}{0.97,0.97,0.97}
\setminted{
    bgcolor=bg,
    fontsize=\small,
    breaklines=true,
    escapeinside=||,
    mathescape=true,
}
\setmintedinline{
    fontsize=\normalsize
}
\newmintinline[injava]{java}{}
\newmintinline[mono]{text}{}
\newmintinline[shell]{shell-session}{}
% Code Listings
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}
\definecolor{vlightgrey}{RGB}{245,245,245}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}

\definecolor{eclipseStrings}{RGB}{42,0.0,255}
\definecolor{eclipseKeywords}{RGB}{127,0,85}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    commentstyle=\color{eclipseStrings}, % style of comment
    stringstyle=\color{eclipseKeywords}, % style of strings
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
	tabsize=2,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    string=[s]{"}{"},
    comment=[l]{:\ "},
    morecomment=[l]{:"},
    literate=
        *{0}{{{\color{numb}0}}}{1}
         {1}{{{\color{numb}1}}}{1}
         {2}{{{\color{numb}2}}}{1}
         {3}{{{\color{numb}3}}}{1}
         {4}{{{\color{numb}4}}}{1}
         {5}{{{\color{numb}5}}}{1}
         {6}{{{\color{numb}6}}}{1}
         {7}{{{\color{numb}7}}}{1}
         {8}{{{\color{numb}8}}}{1}
         {9}{{{\color{numb}9}}}{1}
}

\lstdefinestyle{code}{
    language=bash,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\begin{document}

\begin{sloppypar}
\begin{titlepage}
	\clearpage\thispagestyle{empty}
	\centering
	\vspace{1cm}

    \includegraphics[scale=0.60]{images/unipi-logo.png}
    
	{\normalsize \noindent Dipartimento di Informatica \\
	             Corso di Laurea in Informatica \par}
	
	\vspace{2cm}
	{\Huge \textbf{Progetto di Laboratorio di Reti} \par}
	\vspace{1cm}
	{\large Reti di calcolatori e laboratorio}
	\vspace{5cm}

    \begin{minipage}[t]{0.47\textwidth}
    	{\large{ Prof.ssa Laura Ricci \\ Dott. Matteo Loporchio}}
    \end{minipage}\hfill\begin{minipage}[t]{0.47\textwidth}\raggedleft
    	{\large {Giacomo Trapani \\ 600124 - Corso A\\ }}
    \end{minipage}

    \vspace{4cm}

	{\normalsize Anno Accademico 2021/2022 \par}

	\pagebreak
\end{titlepage}
\subsection{Premessa.}
Il progetto consiste nella progettazione e realizzazione di un Social Network chiamato \textbf{WINSOME} ispirato a STEEMIT e che prevede
ricompense in una valuta chiamata \textbf{WINCOIN} per i propri utenti. L'architettura utilizzata \`e di tipo ``client-server'': il client
comunica attraverso la rete le proprie richieste al server.

Il progetto \`e stato sviluppato utilizzando l'editor di testo \textbf{VSCode} e testato in ambiente Linux; di seguito, gli output dei comandi
\mono{javac -version} e \mono{java -version}:
\begin{lstlisting}[style=code]
	javac 11.0.13
	openjdk version "11.0.13" 2021-10-19
	OpenJDK Runtime Environment 18.9 (build 11.0.13+8)
	OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)
\end{lstlisting}
Per ``orientarsi'' tra le varie directories e avere un'idea approssimativa dell'organizzazione del progetto, si rimanda al file
\mono{README.md}.

All'interno della cartella \mono{docs} viene resa disponibile la documentazione del codice.

Per la compilazione, viene messo a disposizione un Makefile con i target \mono{build} per la creazione dei file .jar, \mono{docs} per
la documentazione, \mono{all} per compilare.

Per l'esecuzione vengono messi a disposizione due script \mono{run_client.sh} e \mono{run_server.sh} che si occupano (rispettivamente)
di avviare l'esecuzione del client e del server (per entrambi, procedono anche alla compilazione nel caso in cui questa non sia ancora
avvenuta).

\subsection{Server.}
Il server dipende dal file di configurazione di cui si passa il path da linea di comando (in caso
contrario, prover\`a a usare il file di configurazione \mono{./configs/server.properties});
il file passato dovr\`a essere del seguente tipo:
\begin{lstlisting}[style=code]
SERVERADDRESS=<valid_server_address>
TCPPORT=<tcp_port>
UDPPORT=<udp_port>
MULTICASTADDRESS=<multicast_address>
MULTICASTPORT=<multicast_port>
REGISTRYHOST=<rmi_registry_host>
REGISTRYPORT=<rmi_registry_port>
REGISTERSERVICENAME=<register_service_name>
CALLBACKSERVICENAME=<callback_service_name>
USERSTORAGE=<path/to/users.json>
FOLLOWINGSTORAGE=<path/to/storage/following.json>
TRANSACTIONSSTORAGE=<path/to/storage/transactions.json>
POSTSSTORAGE=<path/to/storage/posts.json>
POSTSINTERACTIONSSTORAGE=<path/to/storage/posts-interactions.json>
BACKUPINTERVAL=<time_between_backups>
LOGFILE=<path/to/log>
REWARDSINTERVAL=<interval_between_rewards_updates>
REWARDSAUTHORPERCENTAGE=<author_percentage>
COREPOOLSIZE=<core_pool_size>
MAXIMUMPOOLSIZE=<maximum_pool_size>
KEEPALIVETIME=<keep_alive_time>
THREADPOOLTIMEOUT=<thread_pool_timeout>
\end{lstlisting}
I parametri possono essere in qualsiasi ordine, non vengono ammessi argomenti non validi (i.e. non si permettono
stringhe dove ci si aspetterebbe un valore numerico) e nessuno \`e opzionale. La sintassi adottata \`e quella dei file
\href{https://en.wikipedia.org/wiki/.properties}{properties}.

\paragraph*{Struttura interna.}
Al momento dell'avvio, il server - sulla base dei parametri specificati nel file di configurazione - eventualmente ripristina utenti e post
precedentemente caricati e inizializza le proprie strutture dati: tra queste si menzionano un thread pool dedicato alla gestione delle
richieste provenienti dai client connessi, dei thread dedicati per il setup di RMI, Multicast, Logging e Backup
(non sottomessi al pool), un insieme concorrente utilizzato dai thread per condividere informazioni sui client e uno shutdown hook per
gestire correttamente la terminazione (che - tipicamente - avviene inviando SIGINT).

Il server funziona seguendo il modello ``manager-worker''; il manager (ossia il \mono{Main}) si mette in ascolto utilizzando un \mono{Selector}
(dunque, si usano sia \textbf{NIO} sia il \textbf{Thread pooling}) e si occupa di accettare nuove connessioni. Ogniqualvolta un canale
risulta essere pronto in lettura o scrittura, istanzia un thread worker dedicato e lo sottomette al thread pool (nel caso in cui il canale
sia disponibile in lettura, si occupa anche di istanziare un buffer da utilizzare per la gestione della richiesta).

\paragraph*{Thread: RMITask.}
Un thread \mono{RMITask} viene istanziato per la gestione di RMI. Provvede a esportare lo storage degli utenti e pubblicare il riferimento
all'oggetto remoto e, se avvenuta con successo, si mette in idle chiamando una \mono{sleep} all'interno di un ciclo infinito; ricevuta
una \mono{interrupt}, si risveglia, libera le risorse allocate e termina.

\paragraph*{Thread: RewardsTask.}
Un thread \mono{RewardsTask} viene istanziato per il calcolo periodico delle ricompense e il conseguente invio del messaggio (di avvenuto
calcolo) via UDP Multicast. La periodicit\`a viene implementata eseguendo una \mono{sleep} per l'intervallo di tempo necessaria; se viene
sollevata una \mono{InterruptedException}, libera le risorse allocate e termina.

\paragraph*{Thread: LoggingTask.}
Un thread \mono{LoggingTask} viene istanziato per gestire il meccanismo di logging. Si occupa di prelevare da una coda concorrente condivisa
coi thread workers il messaggio da salvare nel log e, ricevuta una \mono{interrupt}, libera le risorse allocate e termina.

Di seguito, si indica con ``{[x]}'' il fatto che la stringa ``[x]'' sia presente se x \`e diverso da null.
Un messaggio all'interno del log segue la seguente sintassi:
\begin{lstlisting}[style=code]
# se la richiesta viene gestita correttamente
[<timestamp>][<thread id>][<client id>]{[<username>]}[<comando>][<response code>]
# se il client si disconnette bruscamente
[<timestamp>][<thread id>][<client id>]{[<username>]}[DISCONNECTION]
# se viene sollevata IOException
[<timestamp>][<thread id>][<client id>]{[<username>]}[I/O ERROR <exception message>][DISCONNECTION]
\end{lstlisting}

\paragraph*{Thread: BackupTask.}
Un thread \mono{BackupTask} viene istanziato per gestire il meccanismo di backup. Si occupa di chiamare i metodi forniti dalle API degli
storage (degli utenti e dei post) e si rimette in idle chiamando una \mono{sleep} per l'intervallo di tempo specificato nel file di
configurazione; ricevuta una \mono{interrupt}, termina.

\paragraph*{Thread: ShutdownHook.}
Il main provvede a installare uno shutdown hook che si occupa di inviare \mono{interrupt} a tutti i thread menzionati sopra e di
liberare le risorse allocate.

\paragraph*{Thread worker: RequestHandler.}
Un thread \mono{RequestHandler} viene istanziato per la gestione di un canale disponibile in lettura,
\`e il vero e proprio backbone dell'intero sistema in quanto deve occuparsi del parsing di una richiesta e della conseguente costruzione
del messaggio di risposta. La logica implementata \`e la seguente: si valida la richiesta e la si gestisce ricorrendo ai metodi
forniti dalla API degli storage (degli utenti e dei post), si formatta ed invia la risposta alla coda concorrente condivisa col task
dedicato al logging, si costruisce un messaggio di risposta formato da una coppia (codice, risposta) lo salva su un insieme condiviso
e ``avvisa il manager'' (ossia risveglia il Main che, a questo punto, provveder\`a a registrare il canale in scrittura).

\paragraph*{Thread worker: MessageDispatcher.}
Un thread \mono{MessageDispatcher} viene istanziato per la gestione di un canale disponibile in
scrittura. Si occupa di recuperare il buffer di risposta costruito dal RequestHandler e di inviarlo; infine, risveglia il Main che
registrer\`a nuovamente il canale per eventuali letture successive.

\paragraph*{Strutture dati condivise.}
Il server usa direttamente tre strutture dati condivise (e completamente slegate una dall'altra):
\begin{itemize}[topsep=0pt, itemsep=0pt, parsep=0pt]
	\item l'insieme \mono{toBeRegistered} (istanziato come un
	\mono{ConcurrentHashMap.newKeySet} e utilizzato sia dal manager sia dagli worker) preserva canale, codice dell'operazione per cui
	deve essere registrato (i.e. lettura o scrittura) e il \mono{ByteBuffer} utilizzato finora.
	\item la coda concorrente \mono{logQueue} (istanziata come un \mono{LinkedBlockingQueue} e utilizzata sia dagli worker sia dal
	thread che si occupa del logging) viene concorrentemente riempita dai thread worker e svuotata dal thread che si occupa del logging.
	\item la tabella hash \mono{loggedInClients} (istanziata come una \mono{ConcurrentHashMap}) preserva la coppia canale, nome utente
	con cui quel client ha eseguito l'operazione di login.
\end{itemize}

\subsection{Storage.}
Il server ricorre alle API fornite dalle classi \mono{UserStorage} e \mono{PostStorage} per la gestione di tutte le richieste (valide)
del client. All'interno del package dedicato (i.e. il package \mono{server.storage}), viene fornita la classe dichiarata package
private \mono{Storage} che implementa due meccanismi di backup: \mono{backupCached} che implementa un meccanismo di caching scrivendo
in append nel file specificato tutti e soli i dati dichiarati nuovi (non va a verificarlo, altrimenti si perderebbe tutto il vantaggio
nell'efficienza) e \mono{backupNonCached} che sovrascrive l'intero file specificato andando a salvare tutti i dati. Per effettuare i
backup, nello specifico, sia usano \mono{NIO} e \mono{Gson}.

Di seguito, si andranno a descrivere le classi (e non le interfacce poich\'e meno interessanti e opportunamente documentate nel codice).
\paragraph*{UserMap}
Una \mono{UserMap} \`e uno storage di utenti che fa uso di tabelle hash. Per la descrizione dei metodi implementati, si faccia riferimento
alla documentazione; di seguito si discuteranno le scelte implementative e la gestione della concorrenza.

Utilizzando le tabelle hash \mono{interestsMap} e \mono{followersMap} (oltre alle due ovvie tabelle username->user) si riesce a ridurre
a \(O(1)\) la complessit\`a algoritmica in tempo di tutti i metodi messi a disposizione.

Poich\'e alcuni metodi modificano lo stato
interno dello storage (nello specifico si tratta di \mono{register}, \mono{handleFollowUser}, \mono{handleUnfollowUser} e \mono{backupUsers})
e questo \`e ``distribuito'' su pi\`u variabili, si sceglie di implementare l'atomicit\`a nelle modifiche
utilizzando due strati di \mono{ReentrantReadWriteLock}: il primo strato corrisponde a \mono{backupLock}, acquisita in lettura da tutti
i metodi a eccezione di quello per il backup e al secondo \mono{dataAccessLock}, acquisita in scrittura da tutti e soli i metodi che
modificano lo stato interno dello storage. La prima lock risulta necessaria poich\'e - come evidente dal codice - la classe implementa
un meccanismo di caching e, durante il backup, deve trasferire nei dati cached i dati nuovi (i.e. spostarli da \mono{usersToBeBackedUp}
a \mono{usersBackedUp}).

Si noti inoltre che modificare lo stato interno di un certo utente non corrisponda a modificare lo stato interno dello storage e che i metodi
forniti dalla classe \mono{User} permettano modifiche concorrenti allo stato del medesimo utente.

\paragraph*{PostMap}
Una \mono{PostMap} \`e uno storage di post che fa uso di tabelle hash. Analogamente all'analisi della classe UserMap, si rimanda alla
documentazione per la descrizione dei metodi messi a disposizione e si discuteranno scelte implementative e gestione della concorrenza.

Utilizzando la tabella hash \mono{postsByAuthor} (oltre alle due ovvie tabelle id->post) si riesce a ridurre a \(O(1)\) la complessit\`a
algoritmica in tempo di tutti i metodi messi a disposizione.

Per quanto concerne la gestione della concorrenza, il discorso \`e lo stesso che per la classe UserMap; i metodi in gioco sono per\`o
\mono{handleCreatePost}, \mono{handleDeletePost} (che forza anche un flush della cache al backup successivo), \mono{handleRewin} e
\mono{backupPosts}.

Come prima, si noti che modificare lo stato interno di un certo post non corrisponda a modificare lo stato interno dello storage e che i metodi
forniti dalla classe \mono{RewinPost} permettano modifiche concorrenti allo stato del medesimo post.

\subsection{User.}
La classe \mono{User} descrive un utente all'interno dello storage. Per permettere modifiche in concorrenza allo stato interno di un utente
si fa uso di blocchi \mono{synchronized} all'interno dei metodi.

\subsection{Post.}
La classe astratta \mono{Post} descrive lo scheletro di un post all'interno dello storage. Per la generazione concorrente di nuovi post da
parte di thread differenti, si fa uso di una variabile \mono{generatorID} dichiarata \mono{AtomicInteger}.

\paragraph*{RewinPost.}
La classe \mono{RewinPost} implementa la classe astratta \mono{Post}. Per permettere modifiche in concorrenza allo stato interno
si fa uso di metodi \mono{synchronized}.

\subsection{Client.}
Il client dipende dal file di configurazione di cui si passa il path da linea di comando (in caso
contrario, prover\`a a usare il file di configurazione \mono{./configs/client.properties});
il file passato dovr\`a essere del seguente tipo:
\begin{lstlisting}[style=code]
SERVERADDRESS=<valid_server_address>
TCPPORT=<tcp_port>
UDPPORT=<udp_port>
REGISTRYHOST=<rmi_registry_host>
REGISTRYPORT=<rmi_registry_port>
REGISTERSERVICENAME=<register_service_name>
CALLBACKSERVICENAME=<callback_service_name>
\end{lstlisting}
Valgono le stesse osservazioni fatte per il server (per quanto riguarda il file di configurazione).

Di seguito, si andr\`a a dare una descrizione piuttosto sommaria (sebbene sufficiente) del comportamento del client poich\'e per la descrizione
dei comandi (sia a livello sintattico sia semantico) si rimanda al codice considerato che si tratta solo di inviare e ricevere stringhe
di un certo formato via TCP (le uniche funzionalit\`a davvero implementate dal client riguardano solo la formattazione delle risposte
ricevute dal server).

\paragraph*{Struttura interna.}
Al momento dell'avvio, il client si connette via TCP al server seguendo le indicazioni precisate nel file di configurazione.
Una volta connesso, legge da linea di comando attraverso un loop infinito fino a che non viene inserito il comando di quit ``:q!''.

Per l'invio di messaggi al server e la gestione delle risposte ricevute si fa riferimento alla classe \mono{Command} definita
all'interno del package \mono{Client}.

\paragraph*{Concorrenza e strutture dati condivise.}
Al momento della login, il client invia al server una richiesta per recuperare i followers gi\`a presenti (per l'utente per cui si \`e
effettuata la login) e una (richiesta) per ricevere le coordinate di multicast.

A questo punto, il client istanzia un \mono{RMIFollowerSet} inizializzato con tutti gli utenti ricevuti e un thread di tipo
\mono{MulticastWorker} dedicato
alla gestione dei messaggi di Multicast con cui condivide
\mono{multicastMessage} (una coda concorrente dichiarata di tipo \mono{ConcurrentLinkedQueue}) e, prima di leggere da STDIN un nuovo comando,
controlla se nella coda \`e stato aggiunto un messaggio e, in tal caso, lo rimuove e lo stampa su STDOUT.

\paragraph*{Formattazione dei messaggi di risposta.}
Poich\'e i messaggi ricevuti dal server seguono una certa sintassi e, nel caso in cui contengano delle entit\`a allora queste sono dei
dati JSON validi, il client implementa delle classi definite private static corrispondenti a ciascuno dei possibili dati JSON
ricevibili e utilizza \mono{Gson} per effettuarne il parsing
e, di seguito, istanziare oggetti del tipo appropriato.

\subsection{Protocollo di comunicazione.}
Per la comunicazione tra il client e il server viene messa a dispozione - all'interno del package ``api'' - la classe \mono{Communication}
(all'interno dell'omonimo file).

I messaggi inviati e ricevuti seguono in generale la seguente sintassi: \(LUNGHEZZA+MESSAGGIO\) con LUNGHEZZA la lunghezza di MESSAGGIO
convertito in bytes, + l'operatore di concatenazione e MESSAGGIO il messaggio in bytes: in questo modo si permette al chiamante di essere
sicuro di aver inviato e/o ricevuto per intero un messaggio (evitando qualsivoglia lettura o scrittura parziale).

Nel caso particolare in cui un messaggio M sia formato da una collezione di entit\`a, allora MESSAGGIO sar\`a a sua volta una collezione
di messaggi con la struttura sopra menzionata e, dunque, M sar\`a del tipo
\(LUNGHEZZA_{TOTALE}+\displaystyle\sum_{i=1}^{n}LUNGHEZZA_{i}+MESSAGGIO_{i}\) (intendendo sempre + come operatore di concatenazione).

I metodi che si occupano dell'invio e della ricezione usano \mono{NIO}.

\paragraph*{Codici di risposta.}
Ogni messaggio inviato dal server al client \`e formato da due parti (<codice>, <corpo>) separate dal carattere di controllo CRLF, per
avere informazioni sui codici implementati si rimanda alla classe \mono{ResponseCode} definita all'interno del package \mono{api}.

\end{sloppypar}
\end{document}